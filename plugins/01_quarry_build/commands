#!/bin/bash
#
#	a script that downloads and builds the quarry docker files
#
set -e

# these are the core images we use for our PaaS
export QUARRYFILES_IMAGES=( "hipache" "mongo" "redis" "node" )


# build a single docker file
function install_image {
	# we surpress output for the hipache container cos it breaks otherwise
	if [ ! -d ~/quarryfiles/$1 ]; then
		echo "$1 is not a quarryfile" && exit 1
	fi
	flags=""
	if [ "$1" = 'hipache' ]; then
		flags=" -q"
	fi
	echo "building image $1"
	echo "build $flags -t quarry/$1 ~/quarryfiles/$1"
}

case "$1" in
  buildall)
		# check for the install folder otherwise clone & build
		for IMAGE in "${QUARRYFILES_IMAGES[@]}"
		do
		  install_image $IMAGE
		done
		;;

  cleanup)
    # delete all non-running containers
    docker ps -a | grep 'Exit' |  awk '{print $1}' | xargs docker rm &> /dev/null &
    # delete unused images
    docker images | grep '<none>' |  awk '{print $3}'  | xargs docker rmi &> /dev/null &
    # delete quarry images
    docker images | grep 'quarry/' |  awk '{print $3}'  | xargs docker rmi &> /dev/null &
    # remove the image cache
    rm -rf ~/quarryfiles
    ;;

	build)
		docker ps
		#install_image $2
		;;

  help)
    cat && cat<<EOF
    buildall		      Build all quarry Dockerfiles
    build <image>     Build a named quarry Dockerfile
    cleanup						Reset the host
EOF
    ;;

esac
cat