#!/usr/bin/env bash
set -eo pipefail; [[ $QUARRY_TRACE ]] && set -x

#
#
# NOTE - this should be writing and reading from an etcd server
#
# the file system is a start
#
#

case "$1" in

  # prepare the folders for the db
  db:prepare)
    STACK="$2";
    DB_DIR="$QUARRY_ROOT/$STACK/db"

    mkdir -p $DB_DIR/service
    ;;

  # copy the current worker folder into the previous folder
  db:snapshot)
    STACK="$2";
    DB_DIR="$QUARRY_ROOT/$STACK/db"

    quarry db:prepare $STACK

    if [[ -d $DB_DIR/worker ]]; then
      cp -rf $DB_DIR/worker $DB_DIR/previous
    fi
    ;;

  db:service:list)
    STACK="$2";
    DB_DIR="$QUARRY_ROOT/$STACK/db/service"
    list=""
    for servicefolder in $DB_DIR/* ; do
      servicename=$(echo $servicefolder | awk -F/ '{print $(NF)}')
      list="$list $servicename"
    done
    echo $list
    ;;

  db:service:get)
    STACK="$2";
    SERVICE="$3";
    FILE="$4";

    DB_DIR="$QUARRY_ROOT/$STACK/db"
    FULLPATH="$DB_DIR/service/$SERVICE/$FILE"

    if [[ -f $FULLPATH ]]; then
      cat $FULLPATH
    else
      echo ""
    fi
    ;;

  db:service:set)
    STACK="$2";
    SERVICE="$3";
    FILE="$4";
    VALUE="$5";

    DB_DIR="$QUARRY_ROOT/$STACK/db"
    FOLDER="$DB_DIR/service/$SERVICE"
    FULLPATH="$FOLDER/$FILE"

    mkdir -p $FOLDER
  
    echo $VALUE > $FULLPATH
    ;;

  # each node has a node.json from the build - read a single property of it
  db:build:setting)
    STACK="$2";
    NODE="$3";
    NAME="$4";

    FILE="$QUARRY_ROOT/$STACK/build/$NODE/node.json"
    cat $FILE | json_parse | grep "\[\"$NAME\"\]" | awk '{print $2}'
    ;;

  help)
    cat
    ;;

esac
