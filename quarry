#!/bin/bash
set -e
# where our pluginhook plugins live - each 'commands' file extends the main script
export PLUGIN_PATH=${PLUGIN_PATH:="/var/lib/quarry/plugins"}
# where we run application code
export QUARRY_APPS=${QUARRY_APPS:="$HOME/.quarry/apps"}
# where we keep the root settings (like for hipache)
export QUARRY_HOME=${QUARRY_HOME:="/home/quarry"}

# 128MB
#export memorylimit=134217728
# 64MB
export memorylimit=67108864
# 32MB
#export memorylimit=33554432

########################################################################
#
#
#
# app env
#
#
#
########################################################################

APP_INITIALIZED=""

# get the vars and folders setup for one app
function initialize_app(){

  APP_FOLDER=$1

  # we only do this once
  if [[ ! -z $APP_INITIALIZED ]]; then
    return
  fi

  APP_INITIALIZED="1"


  # if we just run right off the bat then we are running from the current folder
  if [[ -z $APP_FOLDER ]]; then
    APP_FOLDER=`pwd`
  fi

  # make sure we have a deploy id that is different each time
  if [[ -z $DEPLOYID ]]; then
    random_id
    DEPLOYID=$RANDOMID
  fi

  # the name of the app is the folder it is in
  APP_NAME=$(echo $APP_FOLDER | awk -F/ '{print $(NF)}')

  QUARRY_FOLDER="$APP_FOLDER/.quarry"
  RUNTIME_FOLDER="$QUARRY_FOLDER/runtime"
  ENV_FOLDER="$QUARRY_FOLDER/env"

  # we keep this seperate incase they are running inside a funky vm shared folder vagrant style
  ROOT_DATA_FOLDER="$HOME/.quarry/data/$APP_NAME";

  mkdir -p $QUARRY_APPS
  mkdir -p $APP_FOLDER
  mkdir -p $RUNTIME_FOLDER
  mkdir -p $ENV_FOLDER
  mkdir -p $ROOT_DATA_FOLDER

  mkdir -p $RUNTIME_FOLDER/services
  mkdir -p $RUNTIME_FOLDER/data
  mkdir -p $RUNTIME_FOLDER/nodes
  mkdir -p $RUNTIME_FOLDER/deployments

  # the file listing the domains for this app
  # we use hipache to route to here
  DOMAINS_FILE="$APP_FOLDER/domains"

  if [[ ! -f $DOMAINS_FILE ]]; then
    DOMAINS_FILE="$APP_FOLDER/.quarry/domains"
  fi

  # how we will boot the app
  BOOT_COMMAND="/usr/bin/node index.js"
}



########################################################################
#
#
#
# tools
#
#
#
########################################################################

function ensure_root(){
  if [ "$(id -u)" != "0" ]; then
   echo "This script must be run as root" 1>&2
   exit 1
  fi
}

function random_id(){
  RANDOMID=`tr -dc "[0-9]" < /dev/urandom | head -c 8`
}

# generate a random, unused port
function generate_port(){
  RANDOM_PORT=`shuf -i 2000-65000 -n 1`;
  if [[ -n `netstat -ant | grep :$RANDOM_PORT` ]]; then
    wait 1
    generate_port
  fi
}

# return the IP of a given container id
function container_ip(){
  CONTAINER_IP=`docker inspect $1 | grep IPAddress | sed -r 's/\s+"IPAddress": "(([0-9]{1,3}\.){3}[0-9]{1,3})",/\1/'`
}

# list the containers that are status Exit
function dead_containers(){
  DEAD_CONTAINERS=`docker ps -a | grep Exit | awk '{ print $1 }'`
}

# get the internal port for a service
function service_port(){
  if [[ "$1" == "mongo" ]]; then
    SERVICE_PORT=27017
  elif [[ "$1" == "redis" ]]; then
    SERVICE_PORT=6379
  elif [[ "$1" == "hipache" ]]; then
    SERVICE_PORT=6379
  elif [[ "$1" == "etcd" ]]; then
    SERVICE_PORT=4001
  else
    SERVICE_PORT=""
  fi
}

function service_expose_port(){
  if [[ "$1" == "hipache" ]]; then
    EXPOSE_SERVICE_PORT=" -p 80:80"
  elif [[ "$1" == "etcd" ]]; then
    EXPOSE_SERVICE_PORT=" -p 4001:4001"
  else
    EXPOSE_SERVICE_PORT=""
  fi
}

function get_env_string(){

  ENV_STRING=""
  # we loop each of the services needed in the stack
  for i in $QUARRY_FOLDER/env/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then
      envname=$(echo $i | awk -F/ '{print $(NF)}')
      envvalue=$(cat $i)
      ENV_STRING="$ENV_STRING -e=\"$envname=$envvalue\""
    fi

  done
}

########################################################################
#
#
#
# core services
#
#
#
########################################################################

# the things we run as root to keep the quarry os layer going
# (hipache, etcd)
function start_core_service(){
  servicename=$1
  serviceport=$2

  mkdir -p $QUARRY_HOME

  # the already running one
  serviceid=$(docker ps | grep "$servicename" | awk '{print $1}')
  pidfile="$QUARRY_HOME/${servicename^^}_ID"

  # it is not running
  if [[ -z $serviceid ]]; then

    # we have an existing container
    if [[ -f "$pidfile" ]]; then
      serviceid=$(cat "$pidfile")
      docker start $serviceid
    # first time setup
    else
      service_expose_port $servicename
      echo $EXPOSE_SERVICE_PORT
      serviceid=$(docker run -d $EXPOSE_SERVICE_PORT -t quarrystack/$servicename)  
    fi

    container_ip $serviceid
    echo "${servicename^^} IP: $CONTAINER_IP"
    echo "$CONTAINER_IP" > $QUARRY_HOME/${servicename^^}_HOST
    echo "$serviceid" > $QUARRY_HOME/${servicename^^}_ID
    echo "$serviceport" > $QUARRY_HOME/${servicename^^}_PORT
  fi
}

function stop_core_service(){
  servicename=$1
  serviceid=$(docker ps | grep "$servicename" | awk '{print $1}')

  if [[ ! -z $serviceid ]]; then
    docker stop $serviceid
  fi
}

########################################################################
#
#
#
# hipache routing
#
#
#
########################################################################

# netcat a command to the hipache redis
function hipache_command(){
  rediscommand=$1
  redishost=`cat $QUARRY_HOME/HIPACHE_HOST`
  redisport=`cat $QUARRY_HOME/HIPACHE_PORT`
  # pipe the command which waits a fraction of a second after netcatting the redis command
  (echo -en "$rediscommand\r\n"; perl -e "select(undef,undef,undef,0.01);";) | nc $redishost $redisport > /dev/null 2>&1
}

# insert a domain into hipache
function insert_hipache_route(){
  name=$1;
  domain=$2;
  host=$3;
  port=$4;
  standardkey="frontend:$domain"
  wildkey="frontend:*.$domain"
  endpoint="http://$host:$port"

  hipache_command "del $standardkey"
  hipache_command "del $wildkey"
  hipache_command "rpush $standardkey $name"
  hipache_command "rpush $wildkey $name"
  hipache_command "rpush $standardkey $endpoint"
  hipache_command "rpush $wildkey $endpoint"
}




########################################################################
#
#
#
# build
#
#
#
########################################################################

function build_app(){
  ########################################################################
  ########################################################################
  ########################################################################
  ## BUILD

  # digger app
  echo "APP FOLDER: $APP_FOLDER"
  
  if [[ -f "$APP_FOLDER/digger.yaml" ]]; then
    
    echo "compiling digger app $APP_NAME"

    # build the digger app into the .quarry folder - we can study the files after
    # the build is a read only because the files are root inside the container
    docker run -a=stdout -v $APP_FOLDER:/srv/quarryapp -w /srv/quarryapp -t quarrystack/digger /usr/bin/digger build
          
  # we have a manual quarry layout - this is a node.js app but with services they have specified in a quarry layout
  elif [[ -d "$APP_FOLDER/.quarry" ]]; then

    MODE="quarry"
    echo "compiling quarry app $APP_NAME"

  # a normal node app - we want a top level domains file for it
  elif [[ -f "$APP_FOLDER/package.json" ]]; then

    MODE="node"
    echo "compiling nodejs app $APP_NAME"

  else

    MODE="none"

    echo "unknown app type $APP_NAME"
    exit 0;

  fi

  # check if they put their domains file in the .quarry folder
  if [[ ! -f $DOMAINS_FILE ]]; then
    DOMAINS_FILE="$QUARRY_FOLDER/domains"
  fi

  if [[ ! -f $DOMAINS_FILE ]]; then
    echo "domains file is unspecified - put a file called 'domains' in the top level";
    exit 1;
  fi

  # there is a custom bootstrap for the app
  if [[ -f $QUARRY_FOLDER/bootstrap ]]; then
    BOOT_COMMAND=$(cat $QUARRY_FOLDER/bootstrap)
  fi

  # we probably dont need the full paths but lets be sure
  BOOT_COMMAND=`echo "$BOOT_COMMAND" | sed -r "s/^digger/\/usr\/bin\/digger -d \/srv\/quarryapp/"`
  BOOT_COMMAND=`echo "$BOOT_COMMAND" | sed -r "s/^node/\/usr\/bin\/node/"`

  echo $BOOT_COMMAND > $QUARRY_FOLDER/boot_command
}

########################################################################
#
#
#
# services
#
#
#
########################################################################

function boot_services(){
  ########################################################################
  ########################################################################
  ########################################################################
  ## SERVICES

  # we loop each of the services needed in the stack
  for i in $QUARRY_FOLDER/services/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then

      # grab the name of the service off the end of the file -> /dfdf/dfdf/mongo -> mongo
      servicename=$(echo $i | awk -F/ '{print $(NF)}')
      echo "ensuring service: $servicename"

      # read the contents of the service file - this might be a container we have already run
      containerfile=$RUNTIME_FOLDER/services/${servicename^^}
      hostfile=$RUNTIME_FOLDER/services/${servicename^^}_HOST
      portfile=$RUNTIME_FOLDER/services/${servicename^^}_PORT

      containerid=''

      if [[ -f $containerfile ]]; then
        containerid=$(cat $containerfile);
      fi

      # there is no container recorded - create the service
      if [[ -z $containerid ]]; then

        # what internal port does this service run on
        service_port $servicename
        datafolder=$ROOT_DATA_FOLDER/$servicename

        mkdir -p $datafolder

        # run the service container
        # write the container id to the $containerfile
        # mount a volume -> runtime/data/redis
        containerid=$(docker run -d -v $datafolder:/data/db -t quarrystack/$servicename)

        container_ip $containerid
    
        #dockerserviceport=$(docker port $containerid $SERVICE_PORT)

        # we are using the internal docker networking values
        container_ip $containerid

        dockerserviceport=$SERVICE_PORT
        dockerservicehost=$CONTAINER_IP

        # write the container id and port to the runtime
        echo $containerid > $containerfile
        echo $dockerservicehost > $hostfile
        echo $dockerserviceport > $portfile

      else
        dockerrunning=$(docker ps | grep $containerid | awk '{print $1}')
        # we have had a container but it is not running - start it up
        if [[ -z $dockerrunning ]]; then
          docker start $containerid
          echo "service restarting"
        else
          echo "service already running"
        fi
        dockerservicehost=$(cat $hostfile)
        dockerserviceport=$(cat $portfile)
      fi

      # write the service details to the env
      envname=digger_${servicename}_host
      echo $dockerservicehost > $ENV_FOLDER/${envname^^}

      envname=digger_${servicename}_port
      echo $dockerserviceport > $ENV_FOLDER/${envname^^}

      echo "service:                $servicename"
      echo "  * container:          $containerid"
      echo "  * host:               $dockerservicehost"
      echo "  * port:               $dockerserviceport"

      # the contents of the file is the container idc
    fi
  done
}

########################################################################
#
#
#
# image
#
#
#
########################################################################

function prepare_app_image(){

  if [[ $DEPLOY_MODE -eq "production" ]]; then
    echo ""
    echo "---------------------------------------------------"
    echo ""
    echo "creating Dockerfile for app: $APP_FOLDER/Dockerfile"
    echo ""
    echo "---------------------------------------------------"
    echo ""

    # make an image out of the app
    cat<<EOF > $APP_FOLDER/Dockerfile
from quarry/digger

# this clears the docker cach
run echo "$DEPLOYID" > /tmp/quarrydeploy

# add the apps code to the image
add . /srv/quarryapp

# install the npm modules
run cd /srv/quarryapp && rm -rf node_modules && NODE_ENV=production npm install
EOF

    DEPLOY_IMAGE="$APP_NAME/$DEPLOYID"

    # make an image out of the git commit id - this will have installed the node modules
    docker build -t $DEPLOY_IMAGE $APP_FOLDER
  fi
}


########################################################################
#
#
#
# app containers
#
#
#
########################################################################

function run_app_container(){

  ########################################################################
  ########################################################################
  ########################################################################
  ## NOW THE APP

  # any containers we find already running we will clear at the end
  # once we have changed the front end routing
  KILL_CONTAINER=""
  #ARRAY+=('foo')

  BOOT_COMMAND=$(cat $QUARRY_FOLDER/boot_command)

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "booting app: $BOOT_COMMAND"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  # until we get more sophisticated - we have one container per stack

  appnodename="app"

  imagefile=$RUNTIME_FOLDER/nodes/${appnodename^^}_IMAGE
  appcontainerfile=$RUNTIME_FOLDER/nodes/${appnodename^^}
  apphostfile=$RUNTIME_FOLDER/nodes/${appnodename^^}_HOST
  appportfile=$RUNTIME_FOLDER/nodes/${appnodename^^}_PORT

  if [[ -z $DEPLOY_IMAGE ]]; then
    if [[ -f $imagefile ]]; then
      DEPLOY_IMAGE=$(cat $imagefile)
    fi
  fi

  appcontainerid=''

  # the node already exists - get its container id and add to the kill list
  if [[ -f $appcontainerfile ]]; then
    appcontainerid=$(cat $appcontainerfile);
    KILL_CONTAINER="$appcontainerid"
  fi

  if [[ -f $apphostfile ]]; then
    KILL_APP_HOST=$(cat $appcontainerfile)
  fi

  if [[ -f $appportfile ]]; then
    KILL_APP_PORT=$(cat $appcontainerfile);
  fi

  echo "running boot: $BOOT_COMMAND"
  echo "on container: $APP_NAME/$DEPLOYID"

  # make one string that has all of the env in one docker command string
  #get_env_string



  dockercommand="docker run -d -v $QUARRY_FOLDER/env:/srv/quarryapp/.quarry/env -w /srv/quarryapp -m $memorylimit -t $DEPLOY_IMAGE mon \"$BOOT_COMMAND\""

  echo $bootcommand > "$QUARRY_FOLDER/dockercommand"

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "$dockercommand"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  appcontainerid=$(docker run -d -v $QUARRY_FOLDER/env:/srv/quarryapp/.quarry/env -w /srv/quarryapp -m $memorylimit -t $DEPLOY_IMAGE mon "$BOOT_COMMAND")

  # internal network
  container_ip $appcontainerid

  apphost=$CONTAINER_IP
  appport=80

  # write the container id and port to the runtime
  echo $appcontainerid > $appcontainerfile
  echo $apphost > $apphostfile
  echo $appport > $appportfile
  echo $DEPLOY_IMAGE > $imagefile

  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "$APP_NAME is created:"
  echo "  * container:          $appcontainerid"
  echo "  * host:               $apphost"
  echo "  * port:               $appport"
  echo ""
  echo "--------------------------------------------"
  echo ""

  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "gwanin insert domain tings pon hipache innit"
  echo ""
  echo "--------------------------------------------"
  echo ""
  # read in the domains file and update hipache with the route
  while read domain; do
    echo "   domain: $domain"
    insert_hipache_route "$APP_NAME" "$domain" "$apphost" "$appport"
  done < $DOMAINS_FILE
}

function stop_app(){
  initialize_app
  appnodename="app"

  appcontainerfile=$RUNTIME_FOLDER/nodes/${appnodename^^}

  if [[ -f $appcontainerfile ]]; then
    docker stop $(cat $appcontainerfile)
  fi

  # we loop each of the services needed in the stack
  for i in $QUARRY_FOLDER/services/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then

      # grab the name of the service off the end of the file -> /dfdf/dfdf/mongo -> mongo
      servicename=$(echo $i | awk -F/ '{print $(NF)}')
      echo "ensuring service: $servicename"

      # read the contents of the service file - this might be a container we have already run
      servicecontainerfile=$RUNTIME_FOLDER/services/${servicename^^}

      if [[ -f $servicecontainerfile ]]; then
        docker stop $(cat $servicecontainerfile)
      fi
    fi

  done
}

function start_app(){
  initialize_app
  appnodename="app"

  appcontainerfile=$RUNTIME_FOLDER/nodes/${appnodename^^}
  containerid=$(cat $appcontainerfile)
  container_running=$(docker ps -q | grep "$containerid")

  boot_services

  if [[ ! -z $container_running ]]; then
    echo "$containerid is already running!"
    exit 0
  fi

  run_app_container
}



########################################################################
#
#
#
# main run method
#
#
#
########################################################################

function run_app(){

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "Can I dig it?"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  initialize_app

  build_app

  boot_services

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "Yes you can!"
  echo ""
  echo "---------------------------------------------------"
  echo ""
  
  # the default image we run
  DEPLOY_IMAGE="quarry/digger"

  # this might change the deploy image
  prepare_app_image

  run_app_container

  # wait a few seconds to let the app sort itself out
  echo ""
  echo "waiting for app to boot..."
  sleep 3
  echo ""
  echo "OK..."

  if [[ ! -z $KILL_CONTAINER ]]; then
    echo ""
    echo "--------------------------------------------"
    echo ""
    echo "killing old container: $KILL_CONTAINER"
    docker stop $KILL_CONTAINER
  fi

  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "all booted captain - she's a goodun!"
  echo ""
}

case "$1" in
  receive)
    APP="$2";

    # fetch the git head to use as the deploy id
    DEPLOYID=$(cd ~/$APP && git rev-parse HEAD | cut -c -8);

    echo "-----> Uploading $APP ..."
    initialize_app "$QUARRY_APPS/$APP"

    # move the input (tar) into where we want it on the filesystem
    # this is run from a gitreceive
    cat | tar -xC $APP_FOLDER

    
    echo "-----> Installing $APP ..."
    quarry run $APP $DEPLOYID production
    #echo "-----> Build complete!"
    #echo "-----> Releasing $APP ..."
    #dokku release $APP $IMAGE
    #echo "-----> Release complete!"
    #echo "-----> Deploying $APP ..."
    #dokku deploy $APP $IMAGE
    #echo "-----> Deploy complete!"
    #echo "-----> Cleaning up ..."
    #dokku cleanup
    #echo "-----> Cleanup complete!"
    #echo "=====> Application deployed:"
    #echo "       $(dokku url $APP)"
    #echo
    ;;

  build)
    initialize_app

    echo "bulding"
    build_app

    ;;

  core)
    ensure_root
    case "$2" in

      start)
        quarry hipache start
        #quarry etcd start
        ;;

      stop)
        quarry hipache stop
        #quarry etcd stop
        ;;

      *)
        echo "usage: quarry core (start|stop)"
        ;;

    esac
    ;;

  # run hipache - this should be done once as root but if it goes wrong this is how you start it
  hipache)
    ensure_root
    case "$2" in

      start)
        service_port hipache
        start_core_service hipache $SERVICE_PORT
        ;;

      stop)
        stop_core_service hipache
        ;;

      connect)
        telnet `cat $QUARRY_HOME/HIPACHE_HOST` `cat $QUARRY_HOME/HIPACHE_PORT`
        ;;

      *)
        echo "usage: quarry hipache (start|stop|connect)"
        ;;

    esac
    ;;

  # run etcd
#  etcd)
#    ensure_root
#    case "$2" in
#
#      start)
#        service_port etcd
#        start_core_service etcd $SERVICE_PORT
#        ;;
#
#      stop)
#        stop_core_service etcd
#        ;;
#
#      *)
#        echo "usage: quarry etcd (start|stop)"
#        ;;
#
#    esac
#    ;;

  app)

    case "$2" in

      start)
        start_app
        ;;

      stop)
        stop_app
        ;;

      *)
        echo "usage: quarry app (start|stop)"
        ;;
    esac
    ;;



  # run an app
  # if passed a folder then that is what we are running
  # otherwise we assume the current folder is the app
  run)
    # this is the full path to the app folder
    # if empty then the current working folder
    APP_FOLDER="$2"

    # the deploy id either from git or manual
    DEPLOYID="$3"

    # are we running development mode where we mount a volume of the codebase so they can change it
    DEPLOY_MODE='production'

    run_app

    ;;

  develop)
    initialize_app
    DEPLOY_MODE='developer'
    build_app
    ;;

  reset)
    ensure_root
    read -p "Are you sure? " -n 1 -r
    echo    # (optional) move to a new line
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      quarry core stop
      rm -rf $QUARRY_HOME/*
      rm -rf $QUARRY_APPS/*
    fi
    ;;

  cleanup)
    # delete all non-running container
    docker ps -a | grep 'Exit' |  awk '{print $1}' | xargs docker rm &> /dev/null &
    # delete unused images
    docker rmi `docker images -a | grep '<none>' | awk '{print $3}'`
    #docker images | grep '<none>' |  awk '{print $3}'  | xargs docker rmi &> /dev/null &
    ;;

  plugins)
    ls -1 -d $PLUGIN_PATH/*/
    ;;

  plugins-install)
    pluginhook install
    ;;

  # temporary hack for https://github.com/progrium/dokku/issues/82
  deploy:all)
    #for app in $(ls -d $HOME/*/); do
    #  APP=$(basename $app);
    #  IMAGE="app/$APP"
    #  dokku deploy $APP $IMAGE
    #done
    ;;

  help)
    cat<<EOF | pluginhook commands help | sort
    help                  Print the list of commands
    hipache (start|stop)  Control the hipache server (as root)
    run                   Run an app from its working folder
    app (start|stop)      Start and stop a running app
    plugins               Print active plugins
    plugins-install       Install active plugins
EOF
    ;;

  *)
    pluginhook commands "$@"
    ;;

esac
