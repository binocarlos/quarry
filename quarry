#!/bin/bash
set -e
# where our pluginhook plugins live - each 'commands' file extends the main script
export PLUGIN_PATH=${PLUGIN_PATH:="/var/lib/quarry/plugins"}
# git deploy apps
export QUARRY_DEPLOY=${QUARRY_APPS:="$HOME/.quarry/apps"}
# root settings
export QUARRY_HOME=${QUARRY_HOME:="/home/quarry"}

# 128MB
#export memorylimit=134217728
# 64MB
#export memorylimit=67108864
# 32MB
export memorylimit=33554432

########################################################################
#
#
#
# app env
#
#
#
########################################################################

APP_INITIALIZED=""

# get the vars and folders setup for one app
function initialize_app(){

  SOURCE_FOLDER=$1

  # if we just run right off the bat then we are running from the current folder
  if [[ -z $SOURCE_FOLDER ]]; then
    SOURCE_FOLDER=`pwd`
  fi

  # make sure we have a deploy id that is different each time
  if [[ -z $DEPLOYID ]]; then
    random_id
    DEPLOYID=$RANDOMID
  fi

  # the name of the app is the folder it is in
  APP_NAME=$(echo $SOURCE_FOLDER | awk -F/ '{print $(NF)}' | sed -r 's/-//')
  APP_FOLDER=$QUARRY_DEPLOY/$APP_NAME

  QUARRY_FOLDER="$APP_FOLDER"
  RUNTIME_FOLDER="$QUARRY_FOLDER/runtime"
  ROOT_DATA_FOLDER="$QUARRY_FOLDER/data"
  ENV_FOLDER="$QUARRY_FOLDER/env"

  mkdir -p $APP_FOLDER
  mkdir -p $QUARRY_FOLDER
  mkdir -p $RUNTIME_FOLDER
  mkdir -p $ENV_FOLDER
  mkdir -p $ROOT_DATA_FOLDER

  mkdir -p $RUNTIME_FOLDER/services
  mkdir -p $RUNTIME_FOLDER/data
  mkdir -p $RUNTIME_FOLDER/nodes
  mkdir -p $RUNTIME_FOLDER/deployments

  echo $QUARRY_FOLDER

  # the file listing the domains for this app
  # we use hipache to route to here
  DOMAINS_FILE="$SOURCE_FOLDER/domains"

  if [[ ! -f $DOMAINS_FILE ]]; then
    DOMAINS_FILE="$SOURCE_FOLDER/.quarry/domains"
  fi

  # how we will boot the app
  BOOT_COMMAND="/usr/bin/node index.js"
}



########################################################################
#
#
#
# tools
#
#
#
########################################################################

function ensure_root(){
  if [ "$(id -u)" != "0" ]; then
   echo "This script must be run as root" 1>&2
   exit 1
  fi
}

function random_id(){
  RANDOMID=`cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1`  
}

# generate a random, unused port
function generate_port(){
  RANDOM_PORT=`shuf -i 2000-65000 -n 1`;
  if [[ -n `netstat -ant | grep :$RANDOM_PORT` ]]; then
    wait 1
    generate_port
  fi
}

# return the IP of a given container id
function container_ip(){
  CONTAINER_IP=`docker inspect $1 | grep IPAddress | sed -r 's/\s+"IPAddress": "(([0-9]{1,3}\.){3}[0-9]{1,3})",/\1/'`
}

# list the containers that are status Exit
function dead_containers(){
  DEAD_CONTAINERS=`docker ps -a | grep Exit | awk '{ print $1 }'`
}

# get the internal port for a service
function service_port(){
  if [[ "$1" == "mongo" ]]; then
    SERVICE_PORT=27017
  elif [[ "$1" == "redis" ]]; then
    SERVICE_PORT=6379
  elif [[ "$1" == "hipache" ]]; then
    SERVICE_PORT=6379
  elif [[ "$1" == "etcd" ]]; then
    SERVICE_PORT=4001
  else
    SERVICE_PORT=""
  fi
}

function service_expose_port(){
  if [[ "$1" == "hipache" ]]; then
    EXPOSE_SERVICE_PORT=" -p 80:80"
  elif [[ "$1" == "etcd" ]]; then
    EXPOSE_SERVICE_PORT=" -p 4001:4001"
  else
    EXPOSE_SERVICE_PORT=""
  fi
}

function get_env_string(){

  ENV_STRING=""

  # we loop each of the services needed in the stack
  for i in $ENV_FOLDER/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then
      envname=$(echo $i | awk -F/ '{print $(NF)}')
      envvalue=$(cat $i)
      ENV_STRING="$ENV_STRING -e $envname=$envvalue"
    fi

  done
}

########################################################################
#
#
#
# core services
#
#
#
########################################################################

# the things we run as root to keep the quarry os layer going
# (hipache, etcd)
function start_core_service(){
  servicename=$1
  serviceport=$2

  mkdir -p $QUARRY_HOME

  # the already running one
  serviceid=$(docker ps | grep "$servicename" | awk '{print $1}')
  pidfile="$QUARRY_HOME/${servicename^^}_ID"

  # it is not running
  if [[ -z $serviceid ]]; then

    # we have an existing container
    if [[ -f "$pidfile" ]]; then
      serviceid=$(cat "$pidfile")
      docker start $serviceid
    # first time setup
    else
      service_expose_port $servicename
      echo $EXPOSE_SERVICE_PORT
      serviceid=$(docker run -d $EXPOSE_SERVICE_PORT -t quarrystack/$servicename)  
    fi

    container_ip $serviceid
    echo "${servicename^^} IP: $CONTAINER_IP"
    echo "$CONTAINER_IP" > $QUARRY_HOME/${servicename^^}_HOST
    echo "$serviceid" > $QUARRY_HOME/${servicename^^}_ID
    echo "$serviceport" > $QUARRY_HOME/${servicename^^}_PORT
  fi
}

function stop_core_service(){
  servicename=$1
  serviceid=$(docker ps | grep "$servicename" | awk '{print $1}')

  if [[ ! -z $serviceid ]]; then
    docker stop $serviceid
  fi
}

########################################################################
#
#
#
# hipache routing
#
#
#
########################################################################

# netcat a command to the hipache redis
function hipache_command(){
  rediscommand=$1
  redishost=`cat $QUARRY_HOME/HIPACHE_HOST`
  redisport=`cat $QUARRY_HOME/HIPACHE_PORT`
  # pipe the command which waits a fraction of a second after netcatting the redis command
  (echo -en "$rediscommand\r\n"; perl -e "select(undef,undef,undef,0.01);";) | nc $redishost $redisport > /dev/null 2>&1
}

# insert a domain into hipache
function insert_hipache_route(){
  name=$1;
  domain=$2;
  host=$3;
  port=$4;
  standardkey="frontend:$domain"
  wildkey="frontend:*.$domain"
  endpoint="http://$host:$port"

  hipache_command "del $standardkey"
  hipache_command "del $wildkey"
  hipache_command "rpush $standardkey $name"
  hipache_command "rpush $wildkey $name"
  hipache_command "rpush $standardkey $endpoint"
  hipache_command "rpush $wildkey $endpoint"
}



########################################################################
#
#
#
# services
#
#
#
########################################################################

function boot_services(){
  ########################################################################
  ########################################################################
  ########################################################################
  ## SERVICES

  # we loop each of the services needed in the stack
  for i in $SOURCE_FOLDER/.quarry/services/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then

      # grab the name of the service off the end of the file -> /dfdf/dfdf/mongo -> mongo
      servicename=$(echo $i | awk -F/ '{print $(NF)}')
      echo "ensuring service: $servicename"

      # read the contents of the service file - this might be a container we have already run
      containerfile=$RUNTIME_FOLDER/services/${servicename^^}
      hostfile=$RUNTIME_FOLDER/services/${servicename^^}_HOST
      portfile=$RUNTIME_FOLDER/services/${servicename^^}_PORT

      containerid=''

      if [[ -f $containerfile ]]; then
        containerid=$(cat $containerfile);
      fi

      service_port $servicename

      # there is no container recorded - create the service
      if [[ -z $containerid ]]; then

        # what internal port does this service run on
        
        datafolder=$ROOT_DATA_FOLDER/$servicename

        mkdir -p $datafolder

        # run the service container
        # write the container id to the $containerfile
        # mount a volume -> runtime/data/redis
        containerid=$(docker run -d -v $datafolder:/data/db -t quarrystack/$servicename)

        container_ip $containerid
    
        #dockerserviceport=$(docker port $containerid $SERVICE_PORT)

        dockerserviceport=$SERVICE_PORT
        dockerservicehost=$CONTAINER_IP

        # write the container id and port to the runtime
        echo $containerid > $containerfile
        echo $dockerservicehost > $hostfile
        echo $dockerserviceport > $portfile

      else
        dockerrunning=$(docker ps | grep $containerid | awk '{print $1}')
        # we have had a container but it is not running - start it up
        if [[ -z $dockerrunning ]]; then
          docker start $containerid
          echo "service restarting"
        else
          echo "service already running"
        fi

        container_ip $containerid
        dockerserviceport=$SERVICE_PORT
        dockerservicehost=$CONTAINER_IP
      fi

      # write the service details to the env
      envname=digger_${servicename}_host
      echo $dockerservicehost > $ENV_FOLDER/${envname^^}

      envname=digger_${servicename}_port
      echo $dockerserviceport > $ENV_FOLDER/${envname^^}

      echo "service:                $servicename"
      echo "  * container:          $containerid"
      echo "  * host:               $dockerservicehost"
      echo "  * port:               $dockerserviceport"

      # the contents of the file is the container idc
    fi
  done
}

########################################################################
#
#
#
# build
#
#
#
########################################################################

function build_digger(){
    # digger app
  echo "SOURCE FOLDER: $SOURCE_FOLDER"

  echo "compiling digger app $APP_NAME"

  rm -rf $SOURCE_FOLDER/.quarry

  # build the digger app into the .quarry folder - we can study the files after
  # the build is a read only because the files are root inside the container
  docker run -a=stdout -v $SOURCE_FOLDER:/srv/quarryapp -w /srv/quarryapp -t quarrystack/digger /usr/bin/digger build
}

function build_image(){
  ########################################################################
  ########################################################################
  ########################################################################
  ## BUILD

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "creating Dockerfile for app: $APP_FOLDER/Dockerfile"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  # make an image out of the app
  cat<<EOF > $SOURCE_FOLDER/Dockerfile
from quarrystack/digger

# this clears the docker cache
run echo "$DEPLOYID" > /tmp/quarrydeploy

# add the apps code to the image
add . /srv/quarryapp

# install the npm modules
run test -f /srv/quarryapp/package.json || echo '{}' > /srv/quarryapp/package.json
run cd /srv/quarryapp && rm -rf /srv/quarryapp/node_modules && NODE_ENV=production npm install
EOF

  DEPLOY_IMAGE="$APP_NAME/app"

  # make an image out of the git commit id - this will have installed the node modules
  docker build -t $DEPLOY_IMAGE $SOURCE_FOLDER

  rm -f $SOURCE_FOLDER/Dockerfile
}


# run the app directly
function develop_app(){
  ########################################################################
  ########################################################################
  ########################################################################
  ## BUILD

  # digger app
  echo "SOURCE FOLDER: $SOURCE_FOLDER"

  nodename=all
  nodefile=$SOURCE_FOLDER/.quarry/nodes/$nodename

  echo "running digger app $APP_NAME"

  BOOT_COMMAND=$(cat $nodefile)

  get_env_string

  docker run -i $ENV_STRING -v $SOURCE_FOLDER:/srv/quarryapp -m $memorylimit -p 80:80 -w /srv/quarryapp -t quarrystack/digger $BOOT_COMMAND

}

########################################################################
#
#
#
# app containers
#
#
#
########################################################################

function insert_app_domains(){
  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "gwanin insert domain tings pon hipache innit"
  echo ""
  echo "--------------------------------------------"
  echo ""
  # read in the domains file and update hipache with the route
  while read domain; do
    echo "   domain: $domain"
    insert_hipache_route "$APP_NAME" "$domain" "$apphost" "$appport"
  done < $DOMAINS_FILE
}


function run_node_container(){
  nodename=$1
  nodefile=$SOURCE_FOLDER/.quarry/nodes/$nodename
  echo "booting node: $nodename"

  ########################################################################
  ########################################################################
  ########################################################################
  ## NOW THE APP

  # any containers we find already running we will clear at the end
  # once we have changed the front end routing
  
  BOOT_COMMAND=$(cat $nodefile)

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "booting node $nodename: $BOOT_COMMAND"
  echo ""
  echo "---------------------------------------------------"
  echo ""
  appcontainerfile=$RUNTIME_FOLDER/nodes/${nodename^^}
  apphostfile=$RUNTIME_FOLDER/nodes/${nodename^^}_HOST
  appportfile=$RUNTIME_FOLDER/nodes/${nodename^^}_PORT

  appcontainerid=''

  # the node already exists - get its container id and add to the kill list
  if [[ -f $appcontainerfile ]]; then
    appcontainerid=$(cat $appcontainerfile)
    #KILL_CONTAINERS+=("$appcontainerid")
    KILL_CONTAINER=$appcontainerid
  fi

  echo "running boot: $BOOT_COMMAND"
  echo "on container: $APP_NAME/app"

  # make one string that has all of the env in one docker command string
  get_env_string

  dockercommand="docker run -i $ENV_STRING -w /srv/quarryapp -m $memorylimit -t $APP_NAME/app mon \"$BOOT_COMMAND\""

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "$dockercommand"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  appcontainerid=$(docker run -d $ENV_STRING -w /srv/quarryapp -m $memorylimit -t $APP_NAME/app mon "$BOOT_COMMAND")

  # get the ip of the new container
  container_ip $appcontainerid

  apphost=$CONTAINER_IP
  appport=80

  # write the container id and port to the runtime
  echo $appcontainerid > $appcontainerfile
  echo $apphost > $apphostfile
  echo $appport > $appportfile      

  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "$APP_NAME is created:"
  echo "  * container:          $appcontainerid"
  echo "  * host:               $apphost"
  echo "  * port:               $appport"
  echo ""
  echo "--------------------------------------------"
  echo ""
}


function run_app_containers(){

  # these are the old containers we kill after
  #KILL_CONTAINERS=()

  # we loop each of the services needed in the stack
  for i in $SOURCE_FOLDER/.quarry/nodes/* ; do

    # each service represents itself as a file named after the service
    if [ -f "$i" ]; then

      # grab the name of the service off the end of the file -> /dfdf/dfdf/mongo -> mongo
      nodename=$(echo $i | awk -F/ '{print $(NF)}')
      run_node_container $nodename
    fi
  done
}

########################################################################
#
#
#
# main run method
#
#
#
########################################################################

function run_app(){

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "Can I dig it?"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  initialize_app

  echo ""
  echo "---------------------------------------------------"
  echo ""
  echo "Yes you can!"
  echo ""
  echo "---------------------------------------------------"
  echo ""

  build_digger
  build_image

  boot_services
  
  run_app_containers

  # wait a few seconds to let the app sort itself out
  echo ""
  echo "waiting for app to boot..."
  sleep 3
  echo ""
  echo "OK..."

  if [[ ! -z $KILL_CONTAINER ]]; then
    echo ""
    echo "--------------------------------------------"
    echo ""
    echo "killing old container: $KILL_CONTAINER"
    docker stop $KILL_CONTAINER
  fi

  echo ""
  echo "--------------------------------------------"
  echo ""
  echo "all booted captain - she's a goodun!"
  echo ""
}

case "$1" in
  receive)
    APP="$2";

    sourcefolder=$QUARRY_DEPLOY/$APP
    # move the input (tar) into where we want it on the filesystem
    # this is run from a gitreceive
    # fetch the git head to use as the deploy id
    DEPLOYID=$(cd ~/$APP && git rev-parse HEAD | cut -c -8);

    echo "-----> Uploading $APP - $DEPLOYID -> $sourcefolder"
    cat | tar -xC $sourcefolder
    
    initialize_app $sourcefolder
    
    echo "-----> Running $APP ..."
    run_app
    ;;

  # run an app
  # if passed a folder then that is what we are running
  # otherwise we assume the current folder is the app
  run)
  
    run_app


    ;;

  develop)

    initialize_app
    
    build_digger

    boot_services

    develop_app

    ;;

  core)
    ensure_root
    case "$2" in

      start)
        quarry hipache start
        quarry etcd start
        ;;

      stop)
        quarry hipache stop
        quarry etcd stop
        ;;

      *)
        echo "usage: quarry core (start|stop)"
        ;;

    esac
    ;;

  # run hipache - this should be done once as root but if it goes wrong this is how you start it
  hipache)
    ensure_root
    case "$2" in

      start)
        service_port hipache
        start_core_service hipache $SERVICE_PORT
        ;;

      stop)
        stop_core_service hipache
        ;;

      connect)
        telnet `cat $QUARRY_HOME/HIPACHE_HOST` `cat $QUARRY_HOME/HIPACHE_PORT`
        ;;

      *)
        echo "usage: quarry hipache (start|stop|connect)"
        ;;

    esac
    ;;

  # run etcd
  etcd)
    ensure_root
    case "$2" in

      start)
        service_port etcd
        start_core_service etcd $SERVICE_PORT
        ;;

      stop)
        stop_core_service etcd
        ;;

      *)
        echo "usage: quarry etcd (start|stop)"
        ;;

    esac
    ;;



  plugins)
    ls -1 -d $PLUGIN_PATH/*/
    ;;

  plugins-install)
    pluginhook install
    ;;

  # temporary hack for https://github.com/progrium/dokku/issues/82
  deploy:all)
    #for app in $(ls -d $HOME/*/); do
    #  APP=$(basename $app);
    #  IMAGE="app/$APP"
    #  dokku deploy $APP $IMAGE
    #done
    ;;

  help)
    cat<<EOF | pluginhook commands help | sort
    help                  Print the list of commands
    hipache (start|stop)  Control the hipache server (as root)
    run                   Run an app from its working folder
    app (start|stop)      Start and stop a running app
    plugins               Print active plugins
    plugins-install       Install active plugins
EOF
    ;;

  *)
    pluginhook commands "$@"
    ;;

esac
