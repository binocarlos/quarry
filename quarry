#!/bin/bash
set -e
# where our pluginhook plugins live - each 'commands' file extends the main script
export PLUGIN_PATH=${PLUGIN_PATH:="/var/lib/quarry/plugins"}
# the local folder in which our running quarry stacks live
export QUARRY_APPS=${QUARRY_APPS:="/home/git/apps"}

# generate a random, unused port
function generate_port(){
  RANDOM_PORT=`shuf -i 2000-65000 -n 1`;
  if [[ -n `netstat -ant | grep :$RANDOM_PORT` ]]; then
    wait 1
    generate_port
  fi
}

# return the IP of a given container id
function container_ip(){
  CONTAINER_IP=`docker inspect $1 | grep IPAddress | sed -r 's/\s+"IPAddress": "(([0-9]{1,3}\.){3}[0-9]{1,3})",/\1/'`
}

# list the containers that are status Exit
function dead_containers(){
  DEAD_CONTAINERS=`docker ps -a | grep Exit | awk '{ print $1 }'`
}

case "$1" in
  receive)
    APP="$2"; IMAGE="app/$APP"
    echo "-----> Installing $APP ..."
    cat | quarry install $APP
    #echo "-----> Building $APP ..."
    #cat | quarry build $IMAGE
    #echo "-----> Build complete!"
    #echo "-----> Releasing $APP ..."
    #dokku release $APP $IMAGE
    #echo "-----> Release complete!"
    #echo "-----> Deploying $APP ..."
    #dokku deploy $APP $IMAGE
    #echo "-----> Deploy complete!"
    #echo "-----> Cleaning up ..."
    #dokku cleanup
    #echo "-----> Cleanup complete!"
    #echo "=====> Application deployed:"
    #echo "       $(dokku url $APP)"
    #echo
    ;;

  install)
    APP="$2"

    # get the app files into home
    mkdir -p $QUARRY_APPS/$APP
    
    # fetch the git head to use as the deploy id
    DEPLOYID=$(cd /home/git/$APP && git rev-parse HEAD | git -c -8);

    # stream the code into the deploy folder
    cat | tar -xC $QUARRY_APPS/$APP/$DEPLOYID;

        #cat | docker run -i -a stdin quarry/builder /bin/bash -c "mkdir -p /app && tar -xC /app")

    if [[ -f "$QUARRY_APPS/$APP/$DEPLOYID/digger.yaml" ]]; then
      # digger app
      echo "digger app"
    else
      # regular app
      echo "regular app"
    fi

    # digger app
    #if[[ -f "$QUARRY_APPS/$APP/$DEPLOYID/digger.yaml" ]]; then
    #    #docker run -t quarry/digger -v $QUARRY_APPS/$APP:/srv/quarryapp -w /srv/quarryapp digger compile
    #fi

    # use the digger image to build the app
    
    ## make a container that is a quarrynode + the application mounted on /app
    #id=$(cat | docker run -i -a stdin quarry/builder /bin/bash -c "mkdir -p /app && tar -xC /app")
    #test $(docker wait $id) -eq 0
    #docker commit $id $IMAGE > /dev/null
    #id=$(docker run -d $IMAGE /build/builder)
    #docker attach $id
    #test $(docker wait $id) -eq 0
    #docker commit $id $IMAGE > /dev/null
    ;;

  build)
    IMAGE="$2"
    mkdir
    ## make a container that is a quarrynode + the application mounted on /app
    #id=$(cat | docker run -i -a stdin quarry/builder /bin/bash -c "mkdir -p /app && tar -xC /app")
    #test $(docker wait $id) -eq 0
    #docker commit $id $IMAGE > /dev/null
    #id=$(docker run -d $IMAGE /build/builder)
    #docker attach $id
    #test $(docker wait $id) -eq 0
    #docker commit $id $IMAGE > /dev/null
    ;;

  release)
    APP="$2"; IMAGE="$3"
    #pluginhook pre-release $APP $IMAGE
    #if [[ -f "$HOME/$APP/ENV" ]]; then
    #  id=$(cat "$HOME/$APP/ENV" | docker run -i -a stdin $IMAGE /bin/bash -c "mkdir -p /app/.profile.d && cat > /app/.profile.d/app-env.sh")
    #  test $(docker wait $id) -eq 0
    #  docker commit $id $IMAGE > /dev/null
    #fi
    #pluginhook post-release $APP $IMAGE
    ;;

  deploy)
    APP="$2"; IMAGE="$3"
    #pluginhook pre-deploy $APP $IMAGE
    #if [[ ! -f "$HOME/$APP/PORT" ]]; then
    #  # First deploy
    #  id=$(docker run -d -p 5000 -e PORT=5000 $IMAGE /bin/bash -c "/start web")
    #  echo $id > "$HOME/$APP/CONTAINER"
    #  port=$(docker port $id 5000)
    #  echo $port > "$HOME/$APP/PORT"
    #  echo "$(< "$HOME/HOSTNAME"):$port" > "$HOME/$APP/ADDRESS"
    #else
      # Regular deploy
    #  oldid=$(< "$HOME/$APP/CONTAINER")
    #  docker kill $oldid > /dev/null
    #  port=$(< "$HOME/$APP/PORT")
    #  id=$(docker run -d -p ":$port" -e "PORT=$port" $IMAGE /bin/bash -c "/start web")
    #  echo $id > "$HOME/$APP/CONTAINER"
    #fi
    #pluginhook post-deploy $APP $port
    ;;

  # ensure the running of a digger service and output the env details
  service)
    APP="$2";
    
    ;;

  cleanup)
    # delete all non-running container
    docker ps -a | grep 'Exit' |  awk '{print $1}' | xargs docker rm &> /dev/null &
    # delete unused images
    docker rmi `docker images -a | grep '<none>' | awk '{print $3}'`
    #docker images | grep '<none>' |  awk '{print $3}'  | xargs docker rmi &> /dev/null &
    ;;

  plugins)
    ls -1 -d $PLUGIN_PATH/*/
    ;;

  plugins-install)
    pluginhook install
    ;;

  # temporary hack for https://github.com/progrium/dokku/issues/82
  deploy:all)
    #for app in $(ls -d $HOME/*/); do
    #  APP=$(basename $app);
    #  IMAGE="app/$APP"
    #  dokku deploy $APP $IMAGE
    #done
    ;;

  help)
    cat<<EOF | pluginhook commands help | sort
    help            Print the list of commands
    plugins         Print active plugins
    plugins-install Install active plugins
EOF
    ;;

  *)
    pluginhook commands "$@"
    ;;

esac
